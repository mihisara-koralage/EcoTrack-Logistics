import mongoose from 'mongoose';

const { Schema } = mongoose;

/**
 * Ticket Model for EcoTrack Logistics System
 * 
 * Provides comprehensive ticket management for customer support and issue tracking:
 * - Customer issue reporting and tracking
 * - Support agent assignment and management
 * - Priority-based workflow automation
 * - Integration with parcel tracking system
 */

const ticketSchema = new Schema(
  {
    // Unique, human-readable ticket identifier
    // Format: TK-YYYYMMDD-XXXX (e.g., TK-20240126-0001)
    ticketId: {
      type: String,
      required: false, // Will be generated by pre-save middleware
      unique: true,
      trim: true,
      index: true, // Fast lookups by ticket ID
      comment: 'Unique human-readable ticket identifier for customer reference'
    },

    // Reference to associated parcel (optional)
    // Links ticket to specific parcel if applicable
    parcel: {
      type: Schema.Types.ObjectId,
      ref: 'Parcel',
      required: false,
      index: true, // Fast lookups by parcel
      comment: 'Associated parcel if ticket relates to specific shipment'
    },

    // User who created the ticket
    // Can be customer, driver, or supervisor
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true, // Fast lookups by creator
      comment: 'User who initiated the ticket'
    },

    // Support agent assigned to handle the ticket
    // Automatically assigned or manually assigned by supervisor
    assignedTo: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: false,
      index: true, // Fast lookups by assignee
      comment: 'Support agent responsible for resolving the ticket'
    },

    // Type of issue being reported
    // Determines workflow and escalation rules
    issueType: {
      type: String,
      required: true,
      enum: ['Lost', 'Delayed', 'Damaged', 'General'],
      default: 'General',
      index: true, // Filtering by issue type
      comment: 'Category of issue: Lost (missing parcel), Delayed (delivery delay), Damaged (package damage), General (other issues)'
    },

    // Priority level for ticket processing
    // Determines response time and escalation
    priority: {
      type: String,
      required: true,
      enum: ['Low', 'Medium', 'High'],
      default: 'Medium',
      index: true, // Priority-based sorting and filtering
      comment: 'Priority level: Low (non-urgent), Medium (standard), High (urgent/critical)'
    },

    // Current status of ticket in workflow
    // Tracks progress through resolution process
    status: {
      type: String,
      required: true,
      enum: ['Open', 'InProgress', 'Resolved'],
      default: 'Open',
      index: true, // Status-based filtering and reporting
      comment: 'Ticket status: Open (new), InProgress (being handled), Resolved (completed)'
    },

    // Detailed description of the issue
    // Rich text support for comprehensive issue reporting
    description: {
      type: String,
      required: true,
      trim: true,
      maxlength: 2000, // Reasonable limit for descriptions
      comment: 'Detailed description of the issue or concern'
    },

    // Resolution details when ticket is resolved
    // Captures solution and closure information
    resolution: {
      type: String,
      required: false,
      trim: true,
      maxlength: 2000,
      comment: 'Description of how the issue was resolved'
    },

    // Resolution category for analytics
    // Helps track common resolution patterns
    resolutionCategory: {
      type: String,
      required: false,
      enum: [
        'Delivered',           // Lost parcel was found and delivered
        'Refunded',           // Financial compensation provided
        'Replaced',           // New parcel sent as replacement
        'Informational',      // Customer inquiry resolved
        'SystemUpdate',       // System issue fixed
        'ProcessImprovement',  // Workflow improved
        'Other'               // Miscellaneous resolution
      ],
      comment: 'Category of resolution for analytics and reporting'
    },

    // Customer satisfaction rating
    // Optional feedback after resolution
    customerSatisfaction: {
      type: Number,
      required: false,
      min: 1,
      max: 5,
      comment: 'Customer satisfaction rating (1-5) after resolution'
    },

    // Internal notes for support team
    // Not visible to customers
    internalNotes: {
      type: String,
      required: false,
      trim: true,
      maxlength: 1000,
      comment: 'Internal notes for support team collaboration'
    },

    // Escalation level for priority tickets
    // Automatic escalation based on time and priority
    escalationLevel: {
      type: Number,
      required: false,
      min: 0,
      max: 3,
      default: 0,
      comment: 'Escalation level: 0 (normal), 1 (team lead), 2 (supervisor), 3 (management)'
    },

    // Estimated resolution time
    // Based on priority and issue type
    estimatedResolutionTime: {
      type: Date,
      required: false,
      comment: 'Estimated time for ticket resolution'
    },

    // Actual resolution time
    // Tracks efficiency metrics
    actualResolutionTime: {
      type: Date,
      required: false,
      comment: 'Actual time when ticket was resolved'
    },

    // Tags for categorization and search
    // Flexible tagging system for better organization
    tags: [{
      type: String,
      trim: true,
      maxlength: 50,
      comment: 'Tags for categorization and search functionality'
    }],

    // Attachments for supporting evidence
    // Files, images, or documents related to the issue
    attachments: [{
      filename: {
        type: String,
        required: true,
        comment: 'Original filename of attachment'
      },
      path: {
        type: String,
        required: true,
        comment: 'File system path to attachment'
      },
      mimeType: {
        type: String,
        required: true,
        comment: 'MIME type of attachment'
      },
      size: {
        type: Number,
        required: true,
        comment: 'File size in bytes'
      },
      uploadedBy: {
        type: Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        comment: 'User who uploaded the attachment'
      },
      uploadedAt: {
        type: Date,
        default: Date.now,
        comment: 'Timestamp when attachment was uploaded'
      }
    }],

    // Activity history for audit trail
    // Tracks all status changes and actions
    activityHistory: [{
      action: {
        type: String,
        required: true,
        enum: [
          'Created',           // Ticket created
          'Assigned',          // Assigned to agent
          'Reassigned',        // Reassigned to different agent
          'StatusChanged',     // Status updated
          'PriorityChanged',   // Priority updated
          'Escalated',        // Ticket escalated
          'CommentAdded',      // Comment or note added
          'AttachmentAdded',   // File attachment added
          'Resolved'           // Ticket resolved
        ],
        comment: 'Type of action performed on ticket'
      },
      performedBy: {
        type: Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        comment: 'User who performed the action'
      },
      timestamp: {
        type: Date,
        default: Date.now,
        comment: 'Timestamp when action was performed'
      },
      details: {
        type: String,
        required: false,
        maxlength: 500,
        comment: 'Additional details about the action'
      },
      previousValue: {
        type: Schema.Types.Mixed,
        required: false,
        comment: 'Previous value before change (for status/priority changes)'
      },
      newValue: {
        type: Schema.Types.Mixed,
        required: false,
        comment: 'New value after change (for status/priority changes)'
      }
    }],

    // Automatic timestamps for tracking
    createdAt: {
      type: Date,
      default: Date.now,
      index: true, // Time-based queries and sorting
      comment: 'Timestamp when ticket was created'
    },
    updatedAt: {
      type: Date,
      default: Date.now,
      index: true, // Time-based queries and sorting
      comment: 'Timestamp when ticket was last updated'
    },

    // Soft delete for audit purposes
    // Tickets are marked as deleted rather than removed
    isDeleted: {
      type: Boolean,
      default: false,
      index: true, // Exclude deleted tickets from queries
      comment: 'Soft delete flag for audit trail preservation'
    },

    deletedAt: {
      type: Date,
      required: false,
      comment: 'Timestamp when ticket was soft deleted'
    },

    deletedBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: false,
      comment: 'User who deleted the ticket'
    }
  },
  {
    // Enable automatic timestamp management
    timestamps: true,
    
    // Collection name in MongoDB
    collection: 'tickets',
    
    // Add virtual fields for computed properties
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
  }
);

// Compound indexes for common queries
ticketSchema.index({ status: 1, priority: 1, createdAt: -1 }); // Dashboard queries
ticketSchema.index({ assignedTo: 1, status: 1 }); // Agent workload
ticketSchema.index({ createdBy: 1, status: 1 }); // Customer tickets
ticketSchema.index({ issueType: 1, status: 1 }); // Issue type analytics
ticketSchema.index({ priority: 1, escalationLevel: 1 }); // Escalation management

// Virtual field for ticket age
ticketSchema.virtual('age').get(function() {
  return Math.floor((Date.now() - this.createdAt) / (1000 * 60 * 60 * 24)); // Days
});

// Virtual field for resolution duration
ticketSchema.virtual('resolutionDuration').get(function() {
  if (this.status === 'Resolved' && this.actualResolutionTime) {
    return Math.floor((this.actualResolutionTime - this.createdAt) / (1000 * 60 * 60)); // Hours
  }
  return null;
});

// Virtual field for overdue status
ticketSchema.virtual('isOverdue').get(function() {
  if (this.status === 'Resolved') return false;
  if (!this.estimatedResolutionTime) return false;
  return Date.now() > this.estimatedResolutionTime;
});

// Pre-save middleware for ticket ID generation
ticketSchema.pre('save', async function(next) {
  if (this.isNew && !this.ticketId) {
    // Generate unique ticket ID
    const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    const sequence = await this.constructor.getNextSequence(date);
    this.ticketId = `TK-${date}-${sequence.toString().padStart(4, '0')}`;
  }
  
  // Update estimated resolution time based on priority
  if (this.isNew || this.isModified('priority')) {
    this.estimatedResolutionTime = this.calculateEstimatedResolutionTime();
  }
  
  next();
});

// Pre-save middleware for activity history
ticketSchema.pre('save', function(next) {
  if (!this.isNew) {
    // Track status changes
    if (this.isModified('status')) {
      this.activityHistory.push({
        action: 'StatusChanged',
        performedBy: this.updatedBy || this.assignedTo,
        previousValue: this._previousStatus,
        newValue: this.status,
        details: `Status changed from ${this._previousStatus} to ${this.status}`
      });
    }
    
    // Track priority changes
    if (this.isModified('priority')) {
      this.activityHistory.push({
        action: 'PriorityChanged',
        performedBy: this.updatedBy || this.assignedTo,
        previousValue: this._previousPriority,
        newValue: this.priority,
        details: `Priority changed from ${this._previousPriority} to ${this.priority}`
      });
    }
  } else {
    // Initial creation
    this.activityHistory.push({
      action: 'Created',
      performedBy: this.createdBy,
      details: 'Ticket created'
    });
  }
  
  next();
});

// Instance method for calculating estimated resolution time
ticketSchema.methods.calculateEstimatedResolutionTime = function() {
  const now = new Date();
  const priorityHours = {
    'Low': 72,      // 3 days
    'Medium': 24,    // 1 day
    'High': 8        // 8 hours
  };
  
  const issueTypeMultipliers = {
    'Lost': 1.5,      // More complex investigation
    'Delayed': 1.2,    // Requires coordination
    'Damaged': 1.3,    // May need inspection
    'General': 1.0     // Standard processing
  };
  
  const baseHours = priorityHours[this.priority] || 24;
  const multiplier = issueTypeMultipliers[this.issueType] || 1.0;
  const totalHours = baseHours * multiplier;
  
  return new Date(now.getTime() + (totalHours * 60 * 60 * 1000));
};

// Static method for getting next sequence number
ticketSchema.statics.getNextSequence = async function(date) {
  const lastTicket = await this.findOne({
    ticketId: { $regex: `^TK-${date}-` }
  }).sort({ ticketId: -1 });
  
  if (!lastTicket) return 1;
  
  const lastSequence = parseInt(lastTicket.ticketId.split('-')[2]);
  return lastSequence + 1;
};

// Static method for finding tickets by user role
ticketSchema.statics.findByUserRole = async function(userId, userRole, options = {}) {
  const query = { isDeleted: false };
  
  switch (userRole) {
    case 'Customer':
      query.createdBy = userId;
      break;
    case 'SupportAgent':
      query.assignedTo = userId;
      break;
    case 'Supervisor':
      // Supervisors can see all tickets
      break;
    default:
      throw new Error('Invalid user role');
  }
  
  return this.find(query)
    .populate('createdBy', 'name email')
    .populate('assignedTo', 'name email')
    .populate('parcel', 'parcelId status')
    .sort(options.sort || { createdAt: -1 })
    .limit(options.limit || 50);
};

// Static method for getting ticket statistics
ticketSchema.statics.getStatistics = async function(filters = {}) {
  const matchQuery = { isDeleted: false, ...filters };
  
  const [
    statusStats,
    priorityStats,
    issueTypeStats,
    resolutionStats
  ] = await Promise.all([
    this.aggregate([
      { $match: matchQuery },
      { $group: { _id: '$status', count: { $sum: 1 } } }
    ]),
    this.aggregate([
      { $match: matchQuery },
      { $group: { _id: '$priority', count: { $sum: 1 } } }
    ]),
    this.aggregate([
      { $match: matchQuery },
      { $group: { _id: '$issueType', count: { $sum: 1 } } }
    ]),
    this.aggregate([
      { $match: { ...matchQuery, status: 'Resolved' } },
      { $group: { _id: '$resolutionCategory', count: { $sum: 1 } } }
    ])
  ]);
  
  return {
    status: statusStats,
    priority: priorityStats,
    issueType: issueTypeStats,
    resolution: resolutionStats
  };
};

const Ticket = mongoose.model('Ticket', ticketSchema);

export default Ticket;
